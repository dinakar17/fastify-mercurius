# ===========================
# ENUMS
# ===========================

enum AccountType {
  SAVINGS_ACCOUNT
  CURRENT_ACCOUNT
  WALLET
  CASH
  CREDIT_CARD
  BNPL
  LOAN_LENT
  LOAN_BORROWED
  FIXED_DEPOSIT
  TRADING_DEMAT
}

enum AccountGroup {
  PREPAID
  POSTPAID
  LOAN
  INVESTMENT
}

enum TransactionType {
  DEBIT
  CREDIT
}

enum CategoryType {
  GENERAL
  INVESTMENT
}

enum InvestmentAction {
  BUY
  SELL
  DIVIDEND
  BONUS
  SPLIT
}

enum RecurringFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum TransactionFilterType {
  credit
  debit
  recurring
  investment
  transfer
}

enum TransactionOrderType {
  new_to_old
  old_to_new
  high_to_low
  low_to_high
}

enum RecurringPatternStatus {
  UPCOMING
  OVERDUE
  PAID
  ALL
}

# ===========================
# ACCOUNT TYPES
# ===========================

type Account {
  accountId: ID!
  accountType: AccountType!
  accountGroup: AccountGroup!
  accountName: String!
  accountNumber: String
  institutionName: String
  currentBalance: String!
  balanceUpdatedAt: String!
  manualBalanceUpdatedAt: String!
  currency: String
  creditLimit: String
  billingCycleDay: Int
  loanAmount: String
  interestRate: String
  loanStartDate: String
  loanEndDate: String
  logoUrl: String
  notes: String
  isActive: Boolean!
  isDefault: Boolean!
  createdAt: String!
  updatedAt: String!
  lastTransactionDate: String
}

# ===========================
# CATEGORY TYPES
# ===========================

type Category {
  categoryId: ID!
  categoryName: String!
  categoryNumber: Int!
  categoryType: CategoryType!
  investmentSector: String
  iconUrl: String
  createdAt: String!
  updatedAt: String!
}

type CustomTransactionName {
  customNameId: ID!
  userId: ID!
  customName: String!
  logoUrl: String
  createdAt: String!
  updatedAt: String!
}

# ===========================
# TRANSACTION TYPES
# ===========================

type Transaction {
  transactionId: ID!
  accountId: ID!
  amount: String!
  currency: String
  transactionType: TransactionType!
  transactionDateTime: String!
  description: String
  location: String
  paymentMethod: String
  attachments: String # JSON string
  
  # Investment fields
  isInvestment: Boolean!
  assetSymbol: String
  quantity: String
  pricePerUnit: String
  investmentAction: InvestmentAction
  feesCharges: String
  
  # Recurring fields
  isRecurring: Boolean!
  recurringFrequency: RecurringFrequency
  recurringPatternName: String
  
  # Transfer fields
  isTransfer: Boolean!
  linkedTransactionId: ID
  
  # Timestamps
  createdAt: String!
  updatedAt: String!
  
  # Related data (from joins)
  accountName: String
  accountNumber: String
  accountLogoUrl: String
  categoryId: ID
  categoryName: String
  categoryNumber: Int
  categoryType: CategoryType
  investmentSector: String
  categoryIconUrl: String
  customNameId: ID
  customNameText: String
  customLogoUrl: String
  
  # Related entities (resolved by loaders)
  account: Account!
  category: Category
  customName: CustomTransactionName
  linkedTransaction: Transaction
}

# ===========================
# RECURRING PATTERN TYPES
# ===========================

type RecurringPattern {
  patternId: ID!
  accountId: ID!
  categoryId: ID!
  customNameId: ID
  
  # Template data
  amount: String!
  transactionType: TransactionType!
  description: String
  location: String
  paymentMethod: String
  
  # Scheduling
  frequency: RecurringFrequency!
  startDate: String!
  endDate: String # null = indefinite
  nextDueDate: String!
  lastGeneratedDate: String
  
  # State
  isActive: Boolean!
  isPaused: Boolean!
  
  # Tracking
  generatedCount: Int!
  skippedCount: Int!
  
  # Metadata
  notes: String
  createdAt: String!
  updatedAt: String!
  
  # Related entities
  account: Account!
  category: Category!
  customName: CustomTransactionName
  
  # Status computed field (for UI filtering)
  status: RecurringPatternStatus!
}

# ===========================
# INVESTMENT HOLDING TYPES
# ===========================

type InvestmentHolding {
  holdingId: ID!
  accountId: ID!
  categoryId: ID!
  assetSymbol: String!
  assetName: String
  totalQuantity: String!
  averageBuyPrice: String
  totalInvestedAmount: String!
  realizedGainLoss: String
  currency: String
  sector: String
  notes: String
  createdAt: String!
  updatedAt: String!
  
  # Related entities
  account: Account!
  category: Category!
}

# ===========================
# INPUT TYPES
# ===========================

input CreateAccountInput {
  accountType: AccountType!
  accountName: String!
  accountNumber: String
  institutionName: String
  logoUrl: String
  accountGroup: AccountGroup!
  initialBalance: String
  creditLimit: String
}

input UpdateAccountInput {
  accountName: String
  accountNumber: String
  institutionName: String
  logoUrl: String
  currentBalance: String
  isActive: Boolean
  isDefault: Boolean
}

input CreateTransactionInput {
  accountId: ID!
  categoryNumber: Int!
  amount: String!
  transactionType: TransactionType!
  transactionDateTime: String!
  customName: String
  description: String
  
  # Investment Related
  isInvestment: Boolean
  assetSymbol: String
  pricePerUnit: String
  quantity: String
  investmentAction: InvestmentAction
  
  # Transfer Related
  isTransfer: Boolean
  otherAccountId: ID
  
  # Recurring Related
  isRecurring: Boolean
  recurringFrequency: RecurringFrequency
  recurringPatternName: String
  
  # Other Optional Settings
  location: String
  paymentMethod: String
}

input UpdateTransactionInput {
  amount: String
  description: String
  categoryNumber: Int
  customName: String
  customNameLogoUrl: String
  transactionDateTime: String
  location: String
  paymentMethod: String
  transactionType: TransactionType
  
  # Investment Related
  isInvestment: Boolean
  assetSymbol: String
  pricePerUnit: String
  quantity: String
  investmentAction: InvestmentAction
  
  # Recurring Related
  isRecurring: Boolean
  recurringFrequency: RecurringFrequency
  recurringPatternName: String
}

input CreateRecurringPatternInput {
  accountId: ID!
  categoryNumber: Int!
  customName: String
  
  # Template data
  amount: String!
  transactionType: TransactionType!
  description: String
  location: String
  paymentMethod: String
  
  # Scheduling
  frequency: RecurringFrequency!
  startDate: String! # ISO 8601 date string
  endDate: String # ISO 8601 date string, null = indefinite
  
  # Metadata
  notes: String
}

input UpdateRecurringPatternInput {
  amount: String
  description: String
  categoryNumber: Int
  customName: String
  location: String
  paymentMethod: String
  transactionType: TransactionType
  
  # Scheduling
  frequency: RecurringFrequency
  startDate: String
  endDate: String
  
  # State changes
  isActive: Boolean
  isPaused: Boolean
  
  # Metadata
  notes: String
}

input GetRecurringPatternsInput {
  status: RecurringPatternStatus # Filter by UPCOMING, OVERDUE, PAID, or ALL
  accountId: [ID!] # Filter by specific accounts
  categoryNumber: Int # Filter by category
  isActive: Boolean # Filter active/inactive patterns
  transactionType: TransactionType # Filter by DEBIT or CREDIT (default: DEBIT)
  limit: Int # Limit results
}

input AmountRangeInput {
  min: String
  max: String
}

input GetTransactionsInput {
  limit: Int
  cursor: String # Cursor for pagination (transaction ID)
  accountId: [ID!] # Support multiple account IDs
  customNameId: ID
  categoryNumber: Int
  order: TransactionOrderType
  type: TransactionFilterType
  month: String # Format: "YYYY-MM"
  search: String # Search by custom name or description
  amountRange: AmountRangeInput # Filter by amount range (min and/or max)
  
  # Additional boolean filters
  isInvestment: Boolean # Filter by investment transactions
  isRecurring: Boolean # Filter by recurring transactions
  isTransfer: Boolean # Filter by transfer transactions
  
  # Date range filters
  startDate: String # ISO 8601 date string
  endDate: String # ISO 8601 date string
  
  # Investment-specific filters
  assetSymbol: String # Filter by specific asset symbol
  investmentAction: InvestmentAction # Filter by investment action (BUY, SELL, etc.)
  
  # Recurring-specific filters
  recurringFrequency: RecurringFrequency # Filter by recurring frequency (DAILY, WEEKLY, etc.)
  
  # Additional filters
  location: String # Filter by location
  paymentMethod: String # Filter by payment method
  
  # Link filters
  investmentHoldingId: ID # Filter by specific investment holding
  recurringPatternId: ID # Filter by specific recurring pattern
}

# ===========================
# RESPONSE TYPES
# ===========================

type TransactionConnection {
  transactions: [Transaction!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}

type DeleteResponse {
  success: Boolean!
  accountId: ID
  transactionId: ID
  patternId: ID
}

type RecurringPatternSummary {
  paid: String!
  overdue: String!
  dueToday: String!
  upcoming: String!
  total: String!
}

type RecurringPatternResponse {
  patterns: [RecurringPattern!]!
  totalCount: Int!
  summary: RecurringPatternSummary!
}

type MonthlyRecurringSummary {
  paid: Int!
  overdue: Int!
  dueToday: Int!
  upcoming: Int!
  total: Int!
}

type MonthlyRecurringPatternsResponse {
  patterns: [RecurringPattern!]!
  summary: MonthlyRecurringSummary!
}

# ===========================
# TOTALS & AGGREGATION TYPES
# ===========================

# The getMyTotals query supports flexible data aggregation with two dimensions:
# 1. groupBy (GroupByDimension): How to split the data
#    - NONE: Return single total for the entire period
#    - ACCOUNT: Split by accounts (useful for account comparison charts)
#    - CATEGORY: Split by categories (useful for spending breakdown)
#    - CUSTOM_NAME: Split by custom transaction names
# 
# 2. timeBucket (TimeBucket): How to split by time
#    - NONE: Use the full date range (startDate to endDate)
#    - MONTH: Split the date range into monthly buckets
# 
# Examples:
# - Array split by accounts (fixed dates):
#   { groupBy: ACCOUNT, timeBucket: NONE, startDate: "2024-01", endDate: "2024-12" }
#   Returns: [{ account: A, total: 100 }, { account: B, total: 200 }]
# 
# - Array split by categories (fixed dates):
#   { groupBy: CATEGORY, timeBucket: NONE, startDate: "2024-01", endDate: "2024-12" }
#   Returns: [{ category: Food, total: 500 }, { category: Transport, total: 300 }]
# 
# - Array split by months (fixed dates divided by months):
#   { groupBy: NONE, timeBucket: MONTH, startDate: "2024-01", endDate: "2024-12" }
#   Returns: [{ month: "2024-01", total: 1000 }, { month: "2024-02", total: 1200 }, ...]
# 
# - Array of [Array split by accounts] split by months:
#   { groupBy: ACCOUNT, timeBucket: MONTH, startDate: "2024-01", endDate: "2024-12" }
#   Returns: [
#     { account: A, month: "2024-01", total: 50 },
#     { account: B, month: "2024-01", total: 100 },
#     { account: A, month: "2024-02", total: 75 },
#     { account: B, month: "2024-02", total: 150 },
#     ...
#   ]

enum GroupByDimension {
  NONE         # No grouping, return single total
  ACCOUNT      # Split by accounts
  CATEGORY     # Split by categories
  CUSTOM_NAME  # Split by custom names
}

enum TimeBucket {
  NONE   # No time bucketing, use full date range
  MONTH  # Split by months
}

input TotalsFilterInput {
  accountIds: [ID!]
  transactionType: TransactionType # CREDIT or DEBIT
  isInvestment: Boolean
  isRecurring: Boolean
  categoryId: ID
  categoryNumber: Int
  customNameId: ID
}

type TotalsFilter {
  accountIds: [ID!]
  transactionType: TransactionType
  isInvestment: Boolean
  isRecurring: Boolean
  categoryId: ID
  categoryNumber: Int
  customNameId: ID
}

input GetTotalsInput {
  startDate: String! # ISO 8601 date string
  endDate: String! # ISO 8601 date string
  filters: TotalsFilterInput
  groupBy: GroupByDimension # How to group the results (account, category, etc.)
  timeBucket: TimeBucket # How to bucket by time (none or month)
  limit: Int # Optional: limit results (only applies when groupBy is set, orders by total descending)
}

type TotalMetadata {
  # For grouping by category
  category: Category
  
  # For grouping by custom name
  customName: CustomTransactionName
  
  # For grouping by account
  account: Account
  
  # For time bucketing - which month/period this result represents
  month: String # ISO 8601 month string (YYYY-MM) when timeBucket is MONTH
}

type TotalResult {
  total: String!
  startDate: String!
  endDate: String!
  filters: TotalsFilter
  metadata: TotalMetadata
}

# ===========================
# PORTFOLIO DISTRIBUTION TYPES
# ===========================

input GetPortfolioDistributionInput {
  accountIds: [ID!] # Optional: filter by specific investment accounts
  categoryIds: [ID!] # Optional: filter by specific investment categories
}

type PortfolioDistributionItem {
  categoryId: ID!
  categoryName: String!
  investmentSector: String
  totalInvestedAmount: String!
  totalCurrentValue: String # Can be calculated on frontend with current prices
  holdingsCount: Int!
  
  # Category details
  category: Category!
}

# ===========================
# QUERIES
# ===========================

type Query {
  # Account queries
  getMyAccounts: [Account!]!
  getAccount(accountId: ID!): Account!
  
  # Transaction queries
  getMyTransactions(options: GetTransactionsInput): TransactionConnection!
  getMyTransaction(transactionId: ID!): Transaction!
  
  # Investment holding queries
  getMyInvestmentHoldings(accountId: ID): [InvestmentHolding!]!
  
  # Portfolio distribution queries
  getMyPortfolioDistribution(input: GetPortfolioDistributionInput): [PortfolioDistributionItem!]!
  
  # Totals & aggregation queries
  getMyTotals(input: GetTotalsInput!): [TotalResult!]!
  
  # Recurring pattern queries
  getMyRecurringPatterns(input: GetRecurringPatternsInput): RecurringPatternResponse!
  getRecurringPattern(patternId: ID!): RecurringPattern!
  getMonthlyRecurringPatterns(year: Int!, month: Int!): MonthlyRecurringPatternsResponse!
}

# ===========================
# MUTATIONS
# ===========================

type Mutation {
  # Account mutations
  createAccount(input: CreateAccountInput!): Account!  
  updateAccount(accountId: ID!, input: UpdateAccountInput!): Account!
  deleteAccount(accountId: ID!): DeleteResponse!
  
  # Transaction mutations
  createTransaction(input: CreateTransactionInput!): Transaction!
  updateTransaction(transactionId: ID!, input: UpdateTransactionInput!): Transaction!
  deleteTransaction(transactionId: ID!): DeleteResponse!
  
  # Recurring pattern mutations
  manageRecurringPattern(
    patternId: ID # Required for update/delete/pause, omit for create
    action: String! # "create", "update", "delete", "pause", "resume"
    input: CreateRecurringPatternInput # Required for create
    updateInput: UpdateRecurringPatternInput # Required for update
  ): RecurringPattern
}
